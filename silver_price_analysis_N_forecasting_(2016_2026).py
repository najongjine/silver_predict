# -*- coding: utf-8 -*-
"""Silver Price Analysis & Forecasting (2016-2026)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/#fileId=https%3A//storage.googleapis.com/kaggle-colab-exported-notebooks/wildojisan/silver-price-analysis-forecasting-2016-2026.bf987f87-8475-406a-be5b-42568e272f38.ipynb%3FX-Goog-Algorithm%3DGOOG4-RSA-SHA256%26X-Goog-Credential%3Dgcp-kaggle-com%2540kaggle-161607.iam.gserviceaccount.com/20260120/auto/storage/goog4_request%26X-Goog-Date%3D20260120T031143Z%26X-Goog-Expires%3D259200%26X-Goog-SignedHeaders%3Dhost%26X-Goog-Signature%3D244eae38a354f78b567bb263a06f1955b11b71fa23f6950c7369f1c75b846b4dfda5ea2cdcb63b114131e3f001dff6be84709c105390943aa879eed67fe1ea3a6716449f08f5f21230cbc688a7754f3c1a37f5711da90e8a3bf6d2d942f7475c749b89b46b393befb18b2b890a35960836f2fd39545a6365f9903a72791c465f337910a689e6faaa6e24938d3dbe49eb65c310b8f0ad514701316858b941d0aaa263fde31d6b6496ab6f0199576119680b693efc02d19c0d1726e9d55d969ba1ee80b01150903d180686746c2f9c907a3b85e54d48bcb5ba8351b7eb7a288c908ef051ed7ad4f843e62ae848a0dfea2c4f6bd8c84107be712eeb10b89d771216
"""

# IMPORTANT: RUN THIS CELL IN ORDER TO IMPORT YOUR KAGGLE DATA SOURCES,
# THEN FEEL FREE TO DELETE THIS CELL.
# NOTE: THIS NOTEBOOK ENVIRONMENT DIFFERS FROM KAGGLE'S PYTHON
# ENVIRONMENT SO THERE MAY BE MISSING LIBRARIES USED BY YOUR
# NOTEBOOK.
import kagglehub
muhammadaammartufail_silver_prices_10_year_data_and_2026_forecast_path = kagglehub.dataset_download('muhammadaammartufail/silver-prices-10-year-data-and-2026-forecast')

print('Data source import complete.')

from IPython.display import Image, display
display(Image(filename='/kaggle/input/silver-notebook-thumbnail/silver_notebook_thumbnail.png'))

"""# Silver Price Analysis & Forecasting (2016-2026)

**Author:** Dr. Aammar Tufail | Codanics  
**Dataset:** Yahoo Finance (SI=F - Silver Futures)  
**Period:** January 2016 - January 2026  
**Forecast Target:** Q1 2026 (Jan, Feb, Mar)

---

## Table of Contents
1. Data Loading & Overview
2. Exploratory Data Analysis (EDA)
3. Time Series Analysis
4. Feature Engineering
5. Machine Learning Forecasting
6. Model Evaluation
7. Future Projections & Market Analysis
8. Conclusions
"""

# Import Libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime, timedelta
import warnings
warnings.filterwarnings('ignore')

# ML Libraries
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
from sklearn.preprocessing import StandardScaler
from sklearn.ensemble import RandomForestRegressor

# Time Series
from prophet import Prophet
from statsmodels.tsa.seasonal import seasonal_decompose
from statsmodels.tsa.stattools import adfuller

# Style
plt.style.use('seaborn-v0_8-whitegrid')
sns.set_palette('husl')
print('All libraries imported successfully!')

"""## 1. Data Loading & Overview"""

# Load the data
df = pd.read_csv('silver_prices_data.csv')

print('\n' + '='*50)
print('Phase 1: Raw Data Loaded (데이터 로딩 직후)')
print('='*50)
print('데이터의 첫 5줄을 봅니다 (Head):')
print(df.head())
print('\n데이터의 모양 (행, 열):', df.shape)
print('='*50 + '\n')

df['Date'] = pd.to_datetime(df['Date'])
df.set_index('Date', inplace=True)

print('\n' + '='*50)
print('Phase 2: Index Setting (날짜를 인덱스로 설정)')
print('='*50)
print('날짜가 인덱스로 들어간 후 데이터:')
print(df.head())
print('='*50 + '\n')

# Drop Volume if it's all NaN (common in some yfinance structure)
if df['Volume'].isnull().all():
    df.drop('Volume', axis=1, inplace=True)

print(f'Date Range: {df.index.min().date()} to {df.index.max().date()}')
print(f'Total Trading Days: {len(df):,}')
print(f'Total Years: {(df.index.max() - df.index.min()).days / 365:.1f} years')
df.head()

# Dataset Info
print('Dataset Information:')
print(df.info())
print('\nStatistical Summary:')
df.describe().round(2)

# Check for missing values
missing = df.isnull().sum()
print('Missing Values Analysis:')
print(missing)
print(f'\nMissing value percentage: {(missing.sum() / len(df) * 100):.2f}%')

"""## 2. Exploratory Data Analysis (EDA)"""

# Silver Price Over Time
fig, ax = plt.subplots(figsize=(14, 6))
ax.plot(df.index, df['Price'], color='#C0C0C0', linewidth=1.5, label='Silver Price')
ax.fill_between(df.index, df['Price'], alpha=0.3, color='silver')
ax.set_title('Silver Price History (2016-2026)', fontsize=16, fontweight='bold')
ax.set_xlabel('Date', fontsize=12)
ax.set_ylabel('Price (USD per oz)', fontsize=12)
ax.legend()
plt.tight_layout()
plt.show()

# Price Distribution
fig, axes = plt.subplots(1, 2, figsize=(14, 5))

# Histogram
axes[0].hist(df['Price'], bins=50, color='silver', edgecolor='gray', alpha=0.7)
axes[0].axvline(df['Price'].mean(), color='red', linestyle='--', label=f'Mean: ${df["Price"].mean():.2f}')
axes[0].axvline(df['Price'].median(), color='blue', linestyle='--', label=f'Median: ${df["Price"].median():.2f}')
axes[0].set_title('Silver Price Distribution', fontsize=14, fontweight='bold')
axes[0].set_xlabel('Price (USD)')
axes[0].set_ylabel('Frequency')
axes[0].legend()

# Box Plot
axes[1].boxplot(df['Price'].dropna(), vert=True)
axes[1].set_title('Silver Price Box Plot', fontsize=14, fontweight='bold')
axes[1].set_ylabel('Price (USD)')

plt.tight_layout()
plt.show()

# Yearly Analysis
df['Year'] = df.index.year
yearly_stats = df.groupby('Year')['Price'].agg(['mean', 'min', 'max', 'std']).round(2)
yearly_stats.columns = ['Avg Price', 'Min Price', 'Max Price', 'Volatility']
print('Yearly Silver Price Statistics:')
yearly_stats

# Yearly Average Price Bar Chart
fig, ax = plt.subplots(figsize=(12, 5))
colors = plt.cm.Blues(np.linspace(0.3, 0.9, len(yearly_stats)))
bars = ax.bar(yearly_stats.index.astype(str), yearly_stats['Avg Price'], color=colors, edgecolor='navy')
ax.set_title('Average Silver Price by Year', fontsize=14, fontweight='bold')
ax.set_xlabel('Year')
ax.set_ylabel('Average Price (USD)')
for bar, val in zip(bars, yearly_stats['Avg Price']):
    ax.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.3, f'${val:.1f}', ha='center', fontsize=9)
plt.tight_layout()
plt.show()

"""## 3. Time Series Analysis"""

# Moving Averages
df['MA_7'] = df['Price'].rolling(window=7).mean()
df['MA_30'] = df['Price'].rolling(window=30).mean()
df['MA_90'] = df['Price'].rolling(window=90).mean()
df['MA_365'] = df['Price'].rolling(window=365).mean()

print('\n' + '='*50)
print('Phase 3: Moving Averages Added (이동평균선 추가)')
print('='*50)
print('MA_7, MA_30 같은 새로운 줄(Column)이 생겼는지 확인:')
print(df[['Price', 'MA_7', 'MA_30']].tail())
print('='*50 + '\n')

fig, ax = plt.subplots(figsize=(14, 6))
ax.plot(df.index, df['Price'], alpha=0.4, label='Daily Price', color='gray')
ax.plot(df.index, df['MA_7'], label='7-Day MA', color='blue', linewidth=1)
ax.plot(df.index, df['MA_30'], label='30-Day MA', color='orange', linewidth=1.5)
ax.plot(df.index, df['MA_90'], label='90-Day MA', color='green', linewidth=2)
ax.set_title('Silver Price with Moving Averages', fontsize=14, fontweight='bold')
ax.set_xlabel('Date')
ax.set_ylabel('Price (USD)')
ax.legend()
plt.tight_layout()
plt.show()

# Seasonal Decomposition
decomposition = seasonal_decompose(df['Price'].dropna(), model='multiplicative', period=252)

fig, axes = plt.subplots(4, 1, figsize=(14, 10))
decomposition.observed.plot(ax=axes[0], title='Observed', color='silver')
decomposition.trend.plot(ax=axes[1], title='Trend', color='blue')
decomposition.seasonal.plot(ax=axes[2], title='Seasonal', color='green')
decomposition.resid.plot(ax=axes[3], title='Residual', color='red')
plt.suptitle('Seasonal Decomposition of Silver Prices', fontsize=14, fontweight='bold', y=1.02)
plt.tight_layout()
plt.show()

# Stationarity Test (ADF)
result = adfuller(df['Price'].dropna())
print('Augmented Dickey-Fuller Test:')
print(f'   ADF Statistic: {result[0]:.4f}')
print(f'   p-value: {result[1]:.4f}')
print(f'   Critical Values:')
for key, value in result[4].items():
    print(f'      {key}: {value:.4f}')
print(f'\n   Series is {"stationary" if result[1] < 0.05 else "non-stationary"}')

"""## 4. Feature Engineering"""

# Create Features
df['Daily_Return'] = df['Price'].pct_change() * 100
df['Volatility_7d'] = df['Daily_Return'].rolling(7).std()
df['Volatility_30d'] = df['Daily_Return'].rolling(30).std()
df['Price_Range'] = df['High'] - df['Low']
df['Month'] = df.index.month
df['DayOfWeek'] = df.index.dayofweek
df['Quarter'] = df.index.quarter

# Lag Features
for lag in [1, 7, 14, 30]:
    df[f'Price_Lag_{lag}'] = df['Price'].shift(lag)

print('\n' + '='*50)
print('Phase 4: Feature Engineering (보조 지표 추가)')
print('='*50)
print('Lag(과거 가격), Volatility(변동성) 등 새로운 힌트들이 생겼습니다.')
print('새로 생긴 컬럼들:', df.columns.tolist())
print('\n데이터 예시 (마지막 5줄):')
print(df.tail()[['Price', 'Daily_Return', 'Volatility_7d', 'Price_Lag_1']])
print('='*50 + '\n')

print('Feature Engineering Complete!')
print(f'Total Features: {len(df.columns)}')
df.head()

# Correlation Heatmap
corr_cols = ['Price', 'Close', 'High', 'Low', 'Open', 'Daily_Return', 'Volatility_7d']
corr_matrix = df[corr_cols].corr()

fig, ax = plt.subplots(figsize=(10, 8))
sns.heatmap(corr_matrix, annot=True, cmap='coolwarm', center=0, fmt='.2f', ax=ax)
ax.set_title('Feature Correlation Heatmap', fontsize=14, fontweight='bold')
plt.tight_layout()
plt.show()

"""## 5. Machine Learning Forecasting

### 5.1 Prophet Model (Primary)
"""

# Prepare data for Prophet
prophet_df = df[['Price']].reset_index()
prophet_df.columns = ['ds', 'y']
prophet_df = prophet_df.dropna()

print('\n' + '='*50)
print('Phase 5: Prophet Data Prep (예언가 로봇용 데이터 준비)')
print('='*50)
print('Prophet 모델은 "ds"(날짜)와 "y"(값) 두 개만 봅니다.')
print('변환된 데이터 꼬라지:')
print(prophet_df.head())
print('='*50 + '\n')

# Train-test split
train_size = int(len(prophet_df) * 0.8)
train = prophet_df[:train_size]
test = prophet_df[train_size:]

print(f'Training samples: {len(train)}')
print(f'Testing samples: {len(test)}')

# Train Prophet Model
model = Prophet(
    yearly_seasonality=True,
    weekly_seasonality=True,
    daily_seasonality=False,
    changepoint_prior_scale=0.05,
    seasonality_prior_scale=10
)
model.fit(train)
print('Prophet model trained successfully!')

# Make predictions on test set
test_forecast = model.predict(test[['ds']])

# Calculate metrics
y_true = test['y'].values
y_pred = test_forecast['yhat'].values

rmse = np.sqrt(mean_squared_error(y_true, y_pred))
mae = mean_absolute_error(y_true, y_pred)
mape = np.mean(np.abs((y_true - y_pred) / y_true)) * 100
r2 = r2_score(y_true, y_pred)

print('Prophet Model Evaluation Metrics:')
print(f'   RMSE: ${rmse:.2f}')
print(f'   MAE:  ${mae:.2f}')
print(f'   MAPE: {mape:.2f}%')
print(f'   R2:   {r2:.4f}')

# Retrain on full dataset for future forecast
model_full = Prophet(
    yearly_seasonality=True,
    weekly_seasonality=True,
    daily_seasonality=False,
    changepoint_prior_scale=0.05,
    seasonality_prior_scale=10
)
exit()
model_full.fit(prophet_df)

# Forecast for Q1 2026 (Jan, Feb, Mar)
future_dates = model_full.make_future_dataframe(periods=90, freq='D')
forecast = model_full.predict(future_dates)

# Ensure ds is datetime
forecast['ds'] = pd.to_datetime(forecast['ds'])

# Filter for specific Q1 2026 range
start_date = pd.to_datetime('2026-01-01')
end_date = pd.to_datetime('2026-03-31')
forecast_q1_2026 = forecast[(forecast['ds'] >= start_date) & (forecast['ds'] <= end_date)]

# Plot forecast
fig = model_full.plot(forecast, figsize=(14, 6))
plt.title('Silver Price Forecast (Including Q1 2026)', fontsize=14, fontweight='bold')
plt.xlabel('Date')
plt.ylabel('Price (USD)')
# Highlight Q1 2026
plt.axvspan(start_date, end_date, color='green', alpha=0.1, label='Q1 2026 Forecast')
plt.legend()
plt.xlim(pd.to_datetime('2025-06-01'), pd.to_datetime('2026-04-01')) # Zoom in
plt.tight_layout()
plt.show()

# Plot components
fig = model_full.plot_components(forecast)
plt.suptitle('Forecast Components', fontsize=14, fontweight='bold', y=1.02)
plt.tight_layout()
plt.show()

# Forecast Table for Q1 2026
forecast_export = forecast_q1_2026[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].copy()
forecast_export.columns = ['Date', 'Predicted_Price', 'Lower_Bound', 'Upper_Bound']
forecast_export = forecast_export.round(2)
print('\n' + '='*50)
print('Phase 6: Final Prediction (최종 예측 결과)')
print('='*50)
print('2026년 1분기 예측값 (Date, Predicted_Price, Lower_Bound, Upper_Bound):')
print(f'데이터 개수 (Rows): {len(forecast_export)}')
print(forecast_export.head())
print('='*50 + '\n')

"""### 5.2 Random Forest Model (Comparison)"""

# Prepare data for Random Forest
features = ['Close', 'High', 'Low', 'Open', 'MA_7', 'MA_30', 'Volatility_7d', 'Month', 'DayOfWeek', 'Price_Lag_1', 'Price_Lag_7']
df_ml = df[features + ['Price']].dropna().copy()
X = df_ml[features]
y = df_ml['Price']

print(f'ML Dataset Shape: {df_ml.shape}')

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)

# Scale features
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

# Train Random Forest
rf_model = RandomForestRegressor(n_estimators=100, max_depth=10, random_state=42, n_jobs=-1)
rf_model.fit(X_train_scaled, y_train)

# Predictions
rf_pred = rf_model.predict(X_test_scaled)

# Metrics
rf_rmse = np.sqrt(mean_squared_error(y_test, rf_pred))
rf_mae = mean_absolute_error(y_test, rf_pred)
rf_r2 = r2_score(y_test, rf_pred)

print('Random Forest Model Evaluation:')
print(f'   RMSE: ${rf_rmse:.2f}')
print(f'   MAE:  ${rf_mae:.2f}')
print(f'   R2:   {rf_r2:.4f}')

# Feature Importance
importance = pd.DataFrame({'Feature': features, 'Importance': rf_model.feature_importances_})
importance = importance.sort_values('Importance', ascending=True)

fig, ax = plt.subplots(figsize=(10, 6))
ax.barh(importance['Feature'], importance['Importance'], color='steelblue')
ax.set_title('Random Forest Feature Importance', fontsize=14, fontweight='bold')
ax.set_xlabel('Importance')
plt.tight_layout()
plt.show()

"""## 6. Model Evaluation & Comparison"""

# Model Comparison Table
comparison = pd.DataFrame({
    'Model': ['Prophet', 'Random Forest'],
    'RMSE ($)': [rmse, rf_rmse],
    'MAE ($)': [mae, rf_mae],
    'R2': [r2, rf_r2]
})
print('Model Comparison:')
comparison.round(4)

# Actual vs Predicted Plot
fig, ax = plt.subplots(figsize=(14, 6))
ax.plot(test['ds'].values, y_true, label='Actual', color='black', linewidth=2)
ax.plot(test['ds'].values, y_pred, label='Prophet Predicted', color='blue', alpha=0.7)
ax.fill_between(test['ds'].values, test_forecast['yhat_lower'].values, test_forecast['yhat_upper'].values, alpha=0.2, color='blue')
ax.set_title('Actual vs Predicted Silver Prices (Test Set)', fontsize=14, fontweight='bold')
ax.set_xlabel('Date')
ax.set_ylabel('Price (USD)')
ax.legend()
plt.tight_layout()
plt.show()

"""## 7. Market Analysis & Future Projections

### 7.1 Reasons for Silver Price Hype in 2024-2026

**1. Industrial Demand Surge**
- **Solar Energy Boom**: Silver is essential for solar panel production. Global solar capacity is expanding rapidly.
- **Electric Vehicles (EVs)**: Each EV uses 25-50 grams of silver for electrical contacts and batteries.
- **5G Technology**: Silver's superior conductivity makes it crucial for 5G infrastructure.

**2. Investment Demand**
- **Inflation Hedge**: Silver acts as a store of value during high inflation periods.
- **Economic Uncertainty**: Geopolitical tensions and market volatility drive safe-haven demand.
- **Gold-Silver Ratio**: Historically high ratio suggests silver may be undervalued.

**3. Supply Constraints**
- **Mining Challenges**: Limited new mine development and declining ore grades.
- **Recycling Limitations**: Industrial silver is often not recoverable.
- **Geopolitical Risks**: Major producers face political instability.

**4. Green Energy Transition**
- **Net-Zero Commitments**: Governments accelerating renewable energy adoption.
- **Silver's Irreplaceable Role**: No viable substitute for many applications.

### 7.2 Price Projection Analysis
"""

# Monthly Forecast Summary 2026
forecast_q1_2026['Month'] = forecast_q1_2026['ds'].dt.month_name()
monthly_forecast = forecast_q1_2026.groupby('Month')['yhat'].agg(['mean', 'min', 'max']).round(2)
monthly_forecast.columns = ['Avg Price', 'Min Price', 'Max Price']
monthly_forecast = monthly_forecast.reindex(['January', 'February', 'March'])
print('Monthly Price Forecast for Q1 2026:')
monthly_forecast

# Calculate YoY growth
yearly_avg = df.groupby('Year')['Price'].mean()
yoy_growth = yearly_avg.pct_change() * 100

fig, axes = plt.subplots(1, 2, figsize=(14, 5))

# YoY Growth
colors = ['green' if x > 0 else 'red' for x in yoy_growth.dropna()]
axes[0].bar(yoy_growth.dropna().index.astype(str), yoy_growth.dropna(), color=colors)
axes[0].set_title('Year-over-Year Price Change (%)', fontsize=12, fontweight='bold')
axes[0].set_xlabel('Year')
axes[0].set_ylabel('Change (%)')
axes[0].axhline(y=0, color='black', linestyle='-', linewidth=0.5)

# Cumulative Returns
cumulative_returns = (1 + df['Daily_Return']/100).cumprod() - 1
axes[1].plot(df.index, cumulative_returns * 100, color='silver', linewidth=1.5)
axes[1].fill_between(df.index, cumulative_returns * 100, alpha=0.3, color='silver')
axes[1].set_title('Cumulative Returns (%)', fontsize=12, fontweight='bold')
axes[1].set_xlabel('Date')
axes[1].set_ylabel('Cumulative Return (%)')

plt.tight_layout()
plt.show()

"""## 8. Conclusions

### Key Findings:

1. **Price Trend**: Silver has shown significant upward momentum, especially in 2024-2025.

2. **Q1 2026 Outlook**: The model predicts prices to stabilize/grow in Jan-Mar 2026, driven by continued industrial demand.

3. **Seasonality**: Clear seasonal patterns exist, with Q1 often showing specific movement patterns.

4. **Forecast**: Prophet model predicts continued price stability with potential upward bias through March 2026.

### Investment Considerations:

- Strong industrial demand fundamentals
- Limited supply growth
- Green energy transition tailwinds
- High volatility requires risk management
- Short-term price swings can be significant

---

**Disclaimer**: This analysis is for educational purposes only. Past performance does not guarantee future results. Always consult a financial advisor before making investment decisions.
"""

# Save forecast to CSV (Jan-Mar 2026 Only)
forecast_export.to_csv('silver_price_forecast_2026.csv', index=False)
print('Forecast saved to silver_price_forecast_2026.csv (Jan-Mar 2026 Only)')